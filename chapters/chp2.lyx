#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass tufte-book
\begin_preamble

\end_preamble
\use_default_options true
\begin_modules
knitr
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 1
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<setup, include=FALSE, cache=FALSE>>= 
\end_layout

\begin_layout Plain Layout

library(knitr) 
\end_layout

\begin_layout Plain Layout

options(replace.assign=TRUE,width=50) 
\end_layout

\begin_layout Plain Layout

opts_chunk$set(fig.path='figure/graphics-', cache.path='cache/graphics-',
 fig.align='center', dev='pdf', fig.width=5, fig.height=5, fig.show='hold',
 cache=TRUE, par=TRUE) 
\end_layout

\begin_layout Plain Layout

knit_hooks$set(small.mar=function(before, options, envir){ 
\end_layout

\begin_layout Plain Layout

if(before && options$fig.show!='none'){par(mar=c(3,2,3,.1), cex.lab=1.5,cex.axis=1.5,m
gp=c(3,.7,0),tcl=-.3) }}, crop=hook_pdfcrop) 
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Quick introduction to R
\end_layout

\begin_layout Standard
R is a free statistical programming language that is popular among researchers
 and data miners to build software and analyze data
\begin_inset Foot
status open

\begin_layout Plain Layout
if you want to know more about details about R and its history here is a
 good place to start 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://en.wikipedia.org/wiki/R_(programming_language)
\end_layout

\end_inset


\end_layout

\end_inset

.
 In next sections, we will first get you started with the setup of environment
 for using R and then introduce some basic R operations and data structures
 that will be good to know if you do not have prior experience with R.
 If you need more in depth R introduction you will want to check out some
 beginner level books and online tutorials.
 This website has a bunch of resources listed: 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.introductoryr.co.uk/R_Resources_for_Beginners.html
\end_layout

\end_inset


\end_layout

\begin_layout Section
The setup
\end_layout

\begin_layout Standard
Download and install R 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://cran.r-project.org/
\end_layout

\end_inset

 and RStudio 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.rstudio.com/
\end_layout

\end_inset

 if you do not have them already.
 Rstudio is optional but it is a great tool if you are just starting to
 learn R.
 You will need specific data sets to run the codes in this document.
 Download the data.zip[URL to come] and extract it to your directory of choice.
 The folder name should be 
\begin_inset Quotes eld
\end_inset

data
\begin_inset Quotes erd
\end_inset

 and your R working directory should be level above the data folder.
 That means in your R console, when you type 
\begin_inset Quotes eld
\end_inset


\emph on
dir(
\begin_inset Quotes eld
\end_inset

data
\begin_inset Quotes erd
\end_inset

)
\emph default

\begin_inset Quotes erd
\end_inset

 you should be able to see the contents of the data folder.
 You can change your working directory by 
\emph on
setwd()
\emph default
 command and get your current working directory with 
\emph on
getwd()
\emph default
 command in R
\begin_inset Foot
status open

\begin_layout Plain Layout

\bar under
TIP:
\bar default
 dir() gives you files in your current working directory.
 getwd() gets current directory.
 You may need these at some point.
 
\end_layout

\end_inset

.
 In RStudio, you can click on the top menu and change the location of your
 working directory via user interface.
\end_layout

\begin_layout Subsection
Installing packages
\end_layout

\begin_layout Standard
R packages are add-ons to base R that help you achieve additional tasks
 that are not directly supported by base R.
 It is by the action of these extra functionality that R excels as a tool
 for computational genomics.
 Bioconductor project (
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://bioconductor.org/
\end_layout

\end_inset

) is a dedicated package repository for computational biology related packages.
 However main package repository of R, called CRAN, has also computational
 biology related packages.
 In addition, R-Forge(
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://r-forge.r-project.org/
\end_layout

\end_inset

), GitHub(
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/
\end_layout

\end_inset

), and googlecode(
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://code.google.com
\end_layout

\end_inset

) are other locations where R packages might be hosted.
\end_layout

\begin_layout Standard
You can install CRAN packages using install.packages().
 (# is the comment character in R)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=FALSE>>=
\end_layout

\begin_layout Plain Layout

# install package named "randomForests" from CRAN
\end_layout

\begin_layout Plain Layout

install.packages("randomForests")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can install packages from bioconductor with their specific installer
 script.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=FALSE>>=
\end_layout

\begin_layout Plain Layout

# get the installer package
\end_layout

\begin_layout Plain Layout

source("http://bioconductor.org/biocLite.R")
\end_layout

\begin_layout Plain Layout

# install bioconductor package "rtracklayer"
\end_layout

\begin_layout Plain Layout

biocLite("rtracklayer")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Installing packages from GitHub via install_github function from devtools
 package.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=FALSE>>=
\end_layout

\begin_layout Plain Layout

library(devtools)
\end_layout

\begin_layout Plain Layout

install_github("roxygen")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can install packages from the source files, that usually have .tar.gz
 suffix.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=FALSE,tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

# download the source file
\end_layout

\begin_layout Plain Layout

download.file("http://goo.gl/3pvHYI",
\end_layout

\begin_layout Plain Layout

               destfile="methylKit_0.5.7.tar.gz") 
\end_layout

\begin_layout Plain Layout

# install the package from the source file
\end_layout

\begin_layout Plain Layout

install.packages("methylKit_0.5.7.tar.gz",
\end_layout

\begin_layout Plain Layout

                 repos=NULL,type="source") 
\end_layout

\begin_layout Plain Layout

# delete the source file
\end_layout

\begin_layout Plain Layout

unlink("methylKit_0.5.7.tar.gz")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can also update installed packages from CRAN and Bioconductor.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=FALSE>>=
\end_layout

\begin_layout Plain Layout

# updating CRAN packages
\end_layout

\begin_layout Plain Layout

update.packages()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# updating bioconductor packages
\end_layout

\begin_layout Plain Layout

source("http://bioconductor.org/biocLite.R") 
\end_layout

\begin_layout Plain Layout

biocLite("BiocUpgrade")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
installing packages in custom locations
\end_layout

\begin_layout Standard
If you will be using R on servers or computing clusters rather than your
 personal computer it is unlikey that you will have administrator access
 to install packages.
 In that case, you can install packges in custom locations by telling R
 where to look for additional packages.
 This is done by setting up an 
\emph on
.Renviron
\emph default
 file in your home directory and add the following line:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

R_LIBS=~/Rlibs
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This tells R that 
\begin_inset Quotes eld
\end_inset

Rlibs
\begin_inset Quotes erd
\end_inset

 directory at your home directory will be the first choice of locations
 to look for packages and install packages (The directory name and location
 is up to you above is just an example).
 You should go and create that directory now.
 After that, start a fresh R session and start installing packages.
 From now on, packages will be installed to your local directory where you
 have read-write access.
\end_layout

\begin_layout Subsection
Getting help on R functions and packages
\end_layout

\begin_layout Standard
You can get help on functions by help() and help.search() functions.
 You can list the functions in a package with ls() function
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=FALSE>>=
\end_layout

\begin_layout Plain Layout

libray(MASS)
\end_layout

\begin_layout Plain Layout

ls("package:MASS") # functions in the package
\end_layout

\begin_layout Plain Layout

ls() # objects in your R enviroment
\end_layout

\begin_layout Plain Layout

# get help on hist() function
\end_layout

\begin_layout Plain Layout

?hist
\end_layout

\begin_layout Plain Layout

help("hist")
\end_layout

\begin_layout Plain Layout

# search the word "hist" in help pages
\end_layout

\begin_layout Plain Layout

help.search("hist")
\end_layout

\begin_layout Plain Layout

??hist
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In addition, check 
\bar under
package vignettes
\bar default
 for help and practical understanding of the functions.
 All Bionconductor packages have vignettes that walk you thorugh example
 analysis.
 
\bar under
Google search
\bar default
 will always be helpful as well, there are many blogs and web pages that
 have posts about R.
\end_layout

\begin_layout Section
Computations in R
\end_layout

\begin_layout Standard
R can be used as an ordinary calculator.
 Here are a few examples:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>= 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

2 + 3 * 5       # Note the order of operations.
 
\end_layout

\begin_layout Plain Layout

log(10)        # Natural logarithm with base e
\end_layout

\begin_layout Plain Layout

5^2            # 5 raised to the second power 
\end_layout

\begin_layout Plain Layout

3/2            # Division 
\end_layout

\begin_layout Plain Layout

sqrt(16)      # Square root 
\end_layout

\begin_layout Plain Layout

abs(3-7)      # Absolute value of 3-7 
\end_layout

\begin_layout Plain Layout

pi             # The number 
\end_layout

\begin_layout Plain Layout

exp(2)        # exponential function 
\end_layout

\begin_layout Plain Layout

# This is a comment line  
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Vectors
\end_layout

\begin_layout Standard
Vectors is one the core R data structures.
 R handles vectors easily and intuitively.
 You can create vectors with 
\emph on
c()
\emph default
 function, however that is not the only way.
 The operations on vectors will propagate to all the elements of the vectors.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>= 
\end_layout

\begin_layout Plain Layout

x<-c(1,3,2,10,5)    #create a vector x with 5 components 
\end_layout

\begin_layout Plain Layout

x 
\end_layout

\begin_layout Plain Layout

y<-1:5              #create a vector of consecutive integers y 
\end_layout

\begin_layout Plain Layout

y+2                 #scalar addition 
\end_layout

\begin_layout Plain Layout

2*y                 #scalar multiplication
\end_layout

\begin_layout Plain Layout

y^2                 #raise each component to the second power
\end_layout

\begin_layout Plain Layout

2^y                 #raise 2 to the first through fifth power 
\end_layout

\begin_layout Plain Layout

y                   #y itself has not been unchanged 
\end_layout

\begin_layout Plain Layout

y<-y*2 
\end_layout

\begin_layout Plain Layout

y                   #it is now changed
\end_layout

\begin_layout Plain Layout

r1<-rep(1,3)        # create a vector of 1s, length 3 
\end_layout

\begin_layout Plain Layout

length(r1)           #length of the vector
\end_layout

\begin_layout Plain Layout

class(r1)            # class of the vector
\end_layout

\begin_layout Plain Layout

a<-1                # this is actually a vector length one
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Data types in R
\end_layout

\begin_layout Standard
There are four comon data types in R, they are numeric, logical and character
 and integer.
 All these data types can be used to create vectors natively.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>= 
\end_layout

\begin_layout Plain Layout

#create a numeric vector x with 5 components
\end_layout

\begin_layout Plain Layout

x<-c(1,3,2,10,5)     
\end_layout

\begin_layout Plain Layout

x
\end_layout

\begin_layout Plain Layout

#create a logical vector x
\end_layout

\begin_layout Plain Layout

x<-c(TRUE,FALSE,TRUE)     
\end_layout

\begin_layout Plain Layout

x
\end_layout

\begin_layout Plain Layout

# create a character vector
\end_layout

\begin_layout Plain Layout

x<-c("sds","sd","as")
\end_layout

\begin_layout Plain Layout

x
\end_layout

\begin_layout Plain Layout

class(x)
\end_layout

\begin_layout Plain Layout

# create an integer vector
\end_layout

\begin_layout Plain Layout

x<-c(1L,2L,3L)
\end_layout

\begin_layout Plain Layout

x
\end_layout

\begin_layout Plain Layout

class(x)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Section
Matrices
\end_layout

\begin_layout Standard
A matrix refers to a numeric array of rows and columns.
 You can think of it as a stacked version of vectors where each row or column
 is a vector.
 One of the easiest ways to create a matrix is to combine vectors of equal
 length using 
\emph on
cbind()
\emph default
, meaning 'column bind'
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>= 
\end_layout

\begin_layout Plain Layout

x<-c(1,2,3,4) 
\end_layout

\begin_layout Plain Layout

y<-c(4,5,6,7) 
\end_layout

\begin_layout Plain Layout

m1<-cbind(x,y);m1 
\end_layout

\begin_layout Plain Layout

t(m1)                # transpose of m1
\end_layout

\begin_layout Plain Layout

dim(m1)              # 2 by 5 matrix 
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can also directly list the elements and specify the matrix:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>= 
\end_layout

\begin_layout Plain Layout

m2<-matrix(c(1,3,2,5,-1,2,2,3,9),nrow=3) 
\end_layout

\begin_layout Plain Layout

m2
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Section
Data Frames
\end_layout

\begin_layout Standard
A data frame is more general than a matrix, in that different columns can
 have different modes (numeric, character, factor, etc.).
 A data frame can be constructed by 
\emph on
data.frame()
\emph default
 function.
 For example, we illustrate how to construct a data frame from genomic intervals
 or coordinates.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<width.cutoff=40>>= 
\end_layout

\begin_layout Plain Layout

chr <- c("chr1", "chr1", "chr2", "chr2") 
\end_layout

\begin_layout Plain Layout

strand <- c("-","-","+","+") 
\end_layout

\begin_layout Plain Layout

start<- c(200,4000,100,400) 
\end_layout

\begin_layout Plain Layout

end<-c(250,410,200,450) 
\end_layout

\begin_layout Plain Layout

mydata <- data.frame(chr,start,end,strand)
\end_layout

\begin_layout Plain Layout

#change column names 
\end_layout

\begin_layout Plain Layout

names(mydata) <- c("chr","start","end","strand")   
\end_layout

\begin_layout Plain Layout

mydata # OR this will work too 
\end_layout

\begin_layout Plain Layout

mydata <- data.frame(chr=chr,start=start,end=end,strand=strand) 
\end_layout

\begin_layout Plain Layout

mydata 
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are a variety of ways to extract the elements of a data frame.
 You can extract certain columns using column numbers or names, or you can
 extract certain rows by using row numbers.
 You can also extract data using logical arguments, such as extracting all
 rows that has a value in a column larger than your threshold.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>= 
\end_layout

\begin_layout Plain Layout

mydata[,2:4] # columns 2,3,4 of data frame 
\end_layout

\begin_layout Plain Layout

mydata[,c("chr","start")] # columns chr and start from data frame 
\end_layout

\begin_layout Plain Layout

mydata$start # variable start in the data frame 
\end_layout

\begin_layout Plain Layout

mydata[c(1,3),] # get 1st and 3rd rows 
\end_layout

\begin_layout Plain Layout

mydata[mydata$start>400,] # get all rows where start>400
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Section
Lists
\end_layout

\begin_layout Standard
An ordered collection of objects (components).
 A list allows you to gather a variety of (possibly unrelated) objects under
 one name.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<tidy=FALSE>>=
\end_layout

\begin_layout Plain Layout

# example of a list with 4 components 
\end_layout

\begin_layout Plain Layout

# a string, a numeric vector, a matrix, and a scalar 
\end_layout

\begin_layout Plain Layout

w <- list(name="Fred",            
\end_layout

\begin_layout Plain Layout

       mynumbers=c(1,2,3),            
\end_layout

\begin_layout Plain Layout

       mymatrix=matrix(1:4,ncol=2),            
\end_layout

\begin_layout Plain Layout

       age=5.3) 
\end_layout

\begin_layout Plain Layout

w
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can extract elements of a list using the [[]] convention using either
 its position in the list or its name.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>= 
\end_layout

\begin_layout Plain Layout

w[[3]] # 3rd component of the list 
\end_layout

\begin_layout Plain Layout

w[["mynumbers"]] # component named mynumbers in list 
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Factors
\end_layout

\begin_layout Standard
Factors are used to store categorical data.
 They are important for statistical modeling since categorical variables
 are treated differently in statistical models than continuos variables.
 This ensures categorical data treated accordingly in statistical models.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>= 
\end_layout

\begin_layout Plain Layout

features=c("promoter","exon","intron") 
\end_layout

\begin_layout Plain Layout

f.feat=factor(features)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Important thing to note is that when you are reading a data.frame with read.table(
) or creating a data frame with data.frame() character columns are stored
 as factors by default, to change this behaviour you need to set 
\emph on
stringsAsFactors=FALSE
\emph default
 in read.table() and/or data.frame() function arguments.
\end_layout

\begin_layout Section
Reading/Writing data 
\end_layout

\begin_layout Standard
Most of the genomics data are in the form of genomic intervals associated
 with a score.
 That means mostly the data will be in table format with columns denoting
 chromosome, start positions, end positions, strand and score.
 One of the popular formats is BED format used primarily by UCSC genome
 browser but most other genome browsers and tools will support BED format.
 We have all the annotation data in BED format.
 In R, you can easily read tabular format data with 
\emph on
read.table()
\emph default
 function.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>= 
\end_layout

\begin_layout Plain Layout

enh.df <- read.table("data/subset.enhancers.hg18.bed", header = FALSE)  # read
 enhancer marker BED file
\end_layout

\begin_layout Plain Layout

cpgi.df <- read.table("data/subset.cpgi.hg18.bed", header = FALSE) # read CpG
 island BED file
\end_layout

\begin_layout Plain Layout

# check first lines to see how the data looks like 
\end_layout

\begin_layout Plain Layout

head(enh.df) 
\end_layout

\begin_layout Plain Layout

head(cpgi.df) 
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can save your data by writing it to disk as a text file.
 A data frame or matrix can be written out by using 
\emph on
write.table()
\emph default
 function.
 Now let us write out cpgi.df, we will write it out as a tab-separated file,
 pay attention to the arguments.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=FALSE>>= 
\end_layout

\begin_layout Plain Layout

write.table(cpg.df,file="cpgi.txt",quote=FALSE,row.names=FALSE,col.names=FALSE,sep="
\backslash
t")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can save your R objects directly into a file using 
\emph on
save()
\emph default
 and 
\emph on
saveRDS() 
\emph default
and load them back in with load() and readRDS().
 By using these functions you can save any R object whether or not they
 are in data frame or matrix classes.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=FALSE>>= 
\end_layout

\begin_layout Plain Layout

save(cpg.df,enh.df,file="mydata.RData")
\end_layout

\begin_layout Plain Layout

load("mydata.RData")
\end_layout

\begin_layout Plain Layout

# saveRDS() can save one object at a type
\end_layout

\begin_layout Plain Layout

saveRDS(cpg.df,file="cpg.rds")
\end_layout

\begin_layout Plain Layout

x=readRDS("cpg.rds")
\end_layout

\begin_layout Plain Layout

head(x)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
One important thing is that with save() you can save many objects at a time
 and when they are loaded into memory with load() they retain their variable
 names.
 For example, in the above code when you use load("mydata.RData") in a fresh
 R session, an object names 
\begin_inset Quotes eld
\end_inset

cpg.df
\begin_inset Quotes erd
\end_inset

 will be created.
 That means you have to figure out what name you gave it to the objects
 before saving them.
 On the contrary to that, when you save an object by saveRDS() and read
 by readRDS() the name of the object is not retained, you need to assign
 the output of readRDS() to a new variable (
\begin_inset Quotes eld
\end_inset

x
\begin_inset Quotes erd
\end_inset

 in the above code chunk).
\end_layout

\begin_layout Section
Plotting in R
\end_layout

\begin_layout Standard
R has great support for plotting and customizing plots.
 We will show only a few below.
 Let us sample 50 values from normal distribution and plot them as a histogram
 (See Figure
\begin_inset CommandInset ref
LatexCommand ref
reference "mar:hist1"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<hist1, eval=FALSE,tidy=FALSE>>= 
\end_layout

\begin_layout Plain Layout

# sample 50 values from normal distribution 
\end_layout

\begin_layout Plain Layout

# and store them in vector x 
\end_layout

\begin_layout Plain Layout

x<-rnorm(50)  
\end_layout

\begin_layout Plain Layout

hist(x) # plot the histogram of those values 
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float marginfigure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<pdf-hist1, ref.label='hist1', dev='pdf', out.width='
\backslash

\backslash
linewidth', echo=FALSE,small.mar=TRUE>>= 
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Histogram of 50 sampled values 
\begin_inset CommandInset label
LatexCommand label
name "mar:hist1"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 25theight%
\end_inset


\end_layout

\begin_layout Standard
We can modify all the plots by providing certain arguments to the plotting
 function.
 Now let's give a title to the plot using 
\emph on
'main'
\emph default
 argument.
 We can also change the color of the bars using 
\emph on
'col'
\emph default
 argument.
 You can simply provide the name of the color.
 Below, we are using '
\emph on
red
\emph default
' for the color.
 See Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "mar:hist_title"

\end_inset

 for the result this chunk.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<hist2, eval=FALSE>>= 
\end_layout

\begin_layout Plain Layout

hist(x,main="Hello histogram!!!",col="red")  
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float marginfigure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<pdf-hist2, ref.label='hist2', dev='pdf', out.width='
\backslash

\backslash
linewidth', echo=FALSE,small.mar=TRUE>>= 
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Histogram with a title
\begin_inset CommandInset label
LatexCommand label
name "mar:hist_title"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Next, we will plot a scatter plot.
 Scatter plots are one os the most common plots you will encounter in data
 analysis.
 We will sample another set of 50 values and plotted those against the ones
 we sampled earlier.
 Scatterplot shows values of two variables for a set of data points.
 It is useful to visualize relationships between two variables.
 It is frequently used in connection with correlation and linear regression.
 There are other variants of scatter plots which show density of the points
 with different colors.
 We will show examples of those that in following chapters.
 The scatter plot from our sampling experiment is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:scatter-plot-of"

\end_inset

.
 Notice that, in addition to main we used 
\begin_inset Quotes eld
\end_inset

xlab
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

ylab
\begin_inset Quotes erd
\end_inset

 arguments to give labels to the plot.
 You can customize the plots even more than this.
 See ?plot and ?par for more arguments that can help you customize the plots.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<scatter,eval=TRUE,out.width='2in',out.height='2in',tidy=FALSE,small.mar=FALSE
  >>= 
\end_layout

\begin_layout Plain Layout

# randomly sample 50 points from normal distribution 
\end_layout

\begin_layout Plain Layout

y<-rnorm(50)  
\end_layout

\begin_layout Plain Layout

#plot a scatter plot 
\end_layout

\begin_layout Plain Layout

# control x-axis and y-axis labels
\end_layout

\begin_layout Plain Layout

plot(x,y,main="scatterplot of random samples",
\end_layout

\begin_layout Plain Layout

        ylab="y values",xlab="x values")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
scatter plot of two random variables
\begin_inset CommandInset label
LatexCommand label
name "fig:scatter-plot-of"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
we can also plot boxplots for vectors 
\emph on
x
\emph default
 and 
\emph on
y.

\emph default
 Boxplots depict groups of numerical data through their quartiles.
 The edges of the box denote 1st and 3rd quartile, and the line that crosses
 the box is the median.
 Whiskers usually are defined using interquantile range,
\begin_inset Formula $lowerWhisker=Q1-1.5*IQR$
\end_inset

 and 
\begin_inset Formula $upperWhisker=Q1+1.5*IQR$
\end_inset

.
 In addition outliers can be depicted as dots.
 In this case, outliers are the values that remain outside the whiskers.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<boxplot, eval=TRUE,out.width='2in',tidy=FALSE,small.mar=FALSE >>=
\end_layout

\begin_layout Plain Layout

boxplot(x,y,main="boxplots of random samples")  
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Boxplots for x and y vectors
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Next up is bar plot which you can plot by barplot() function.
 We are going to plot four imaginary percentage values and color them with
 two colors, and this time we will also show how to draw a legend on the
 plot using legend() function.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<barplot, eval=TRUE,out.width='2in',tidy=FALSE,small.mar=FALSE >>=
\end_layout

\begin_layout Plain Layout

perc=c(50,70,35,25)
\end_layout

\begin_layout Plain Layout

barplot(height=perc,names.arg=c("CpGi","exon","CpGi","exon"),
\end_layout

\begin_layout Plain Layout

        ylab="percentages",main="imagine %s",
\end_layout

\begin_layout Plain Layout

        col=c("red","red","blue","blue"))
\end_layout

\begin_layout Plain Layout

legend("topright",legend=c("test","control"),fill=c("red","blue"))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Bar plot and legend example
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Saving Plots
\end_layout

\begin_layout Standard
If you want to save your plots to an image file there are couple of ways
 of doing that.
 Normally, you will have to do the following:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{enumerate}
\end_layout

\begin_layout Plain Layout

   
\backslash
item Open a graphics device 
\end_layout

\begin_layout Plain Layout

   
\backslash
item Create the plot 
\end_layout

\begin_layout Plain Layout

   
\backslash
item Close the graphics device 
\end_layout

\begin_layout Plain Layout


\backslash
end{enumerate}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=FALSE>>= 
\end_layout

\begin_layout Plain Layout

pdf("mygraphs/myplot.pdf",width=5,height=5) 
\end_layout

\begin_layout Plain Layout

plot(x,y) 
\end_layout

\begin_layout Plain Layout

dev.off() 
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Alternatively, you can first create the plot then copy the plot to a graphical
 device.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=FALSE>>=
\end_layout

\begin_layout Plain Layout

plot(x,y) 
\end_layout

\begin_layout Plain Layout

dev.copy(pdf,"mygraphs/myplot.pdf",width=7,height=5) 
\end_layout

\begin_layout Plain Layout

dev.off() 
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Section
User defined functions
\end_layout

\begin_layout Standard
Functions are useful for transforming larger chunks of code to re-usable
 pieces of code.
 Generally, if you need to execute certain tasks with variable parameters
 then it is time you write a function.
 A function in R takes different arguments and returns a definite output,
 much like mathematical functions.
 Here is a simple function takes two arguments, x and y, and returns the
 sum of their squares.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

sqSum<-function(x,y){
\end_layout

\begin_layout Plain Layout

result=x^2+y^2
\end_layout

\begin_layout Plain Layout

return(result)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

# now try the function out
\end_layout

\begin_layout Plain Layout

sqSum(2,3)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Functions can also output plots and/or messages to the terminal.
 Here is a function that prints a message to the terminal:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

sqSumPrint<-function(x,y){
\end_layout

\begin_layout Plain Layout

result=x^2+y^2
\end_layout

\begin_layout Plain Layout

cat("here is the result:",result,"
\backslash
n")
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

# now try the function out
\end_layout

\begin_layout Plain Layout

sqSumPrint(2,3)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Section
if-else control structures
\end_layout

\begin_layout Standard
Sometimes we would want to execute a certain part of the code only if certain
 condition is satisfied.
 This condition can be anything from the type of an object (Ex: if object
 is a matrix execute certain code), or it can be more compicated such as
 if object value is between certain thresholds.
 Let us see how they can be used
\begin_inset Foot
status open

\begin_layout Plain Layout
see ?Control for more
\end_layout

\end_inset

.
 They can be used anywhere in your code, now we will use it in a function.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=FALSE>>=
\end_layout

\begin_layout Plain Layout

# function takes input one row
\end_layout

\begin_layout Plain Layout

# of CpGi data frame
\end_layout

\begin_layout Plain Layout

largeCpGi<-function(bedRow){
\end_layout

\begin_layout Plain Layout

 cpglen=bedRow[3]-bedRow[2]+1
\end_layout

\begin_layout Plain Layout

 if(cpglen>1500){
\end_layout

\begin_layout Plain Layout

	cat("this is large
\backslash
n")
\end_layout

\begin_layout Plain Layout

 }
\end_layout

\begin_layout Plain Layout

 else if(cpglen<=1500 & cpglen>700){
\end_layout

\begin_layout Plain Layout

	cat("this is normal
\backslash
n")
\end_layout

\begin_layout Plain Layout

 }
\end_layout

\begin_layout Plain Layout

 else{
\end_layout

\begin_layout Plain Layout

	cat("this is short
\backslash
n")
\end_layout

\begin_layout Plain Layout

 }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

largeCpGi(cpgi.df[10,])
\end_layout

\begin_layout Plain Layout

largeCpGi(cpgi.df[100,])
\end_layout

\begin_layout Plain Layout

largeCpGi(cpgi.df[1000,])
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Section
Loops and looping structures in R
\end_layout

\begin_layout Standard
When you need to repeat a certain task or a execute a function multiple
 times, you can do that with the help of loops.
 A loop will execute the task until a certain condition is reached.
 The loop below is called a 
\begin_inset Quotes eld
\end_inset

for-loop
\begin_inset Quotes erd
\end_inset

 and it executes the task sequentially 10 times.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

for(i in 1:10){ # number of repetitions 
\end_layout

\begin_layout Plain Layout

cat("This is iteration") # the task to be repeated
\end_layout

\begin_layout Plain Layout

print(i) 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The task above is a bit pointless, normally in a loop, you would want to
 do something meaningful.
 Let us calculate the length of the CpG islands we read in earlier.
 Although this is not the most efficient way of doing that particular task,
 it serves as a good example for looping.
 The code below will be execute hundred times, and it will calculate the
 length of the CpG islands for the first 100 islands in the data frame (by
 subtracting the end coordinate from the start coordinate) 
\begin_inset Foot
status open

\begin_layout Plain Layout

\bar under
TIP:
\bar default
 If you are going to run a loop that has a lot of repetitions, it is smart
 to try the loop with few repetitions first and check the results.
 This will help you make sure the code in the loop works before executing
 it for thousands of times.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=TRUE>>=
\end_layout

\begin_layout Plain Layout

# this is where we will keep the lenghts
\end_layout

\begin_layout Plain Layout

# for now it is an empty vector
\end_layout

\begin_layout Plain Layout

result=c() 
\end_layout

\begin_layout Plain Layout

# start the loop
\end_layout

\begin_layout Plain Layout

for(i in 1:100){
\end_layout

\begin_layout Plain Layout

    #calculate the length
\end_layout

\begin_layout Plain Layout

	len=cpgi.df[i,3]-cpgi.df[i,2]+1
\end_layout

\begin_layout Plain Layout

    #append the length to the result
\end_layout

\begin_layout Plain Layout

	result=c(result,len)	
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

# check the results
\end_layout

\begin_layout Plain Layout

head(result)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
apply family functions instead of loops
\end_layout

\begin_layout Standard
R has other ways of repeating tasks that tend to be more efficient than
 using loops.
 They are known as the 
\emph on

\begin_inset Quotes eld
\end_inset

apply
\begin_inset Quotes erd
\end_inset


\emph default
 family of functions, which include 
\emph on
apply,lapply, mapply and tapply
\emph default
 (and some other variants)
\emph on
.

\emph default
 All of these functions apply a given function to a set of instances and
 returns the result of those functions for each instance.
 The differences between them is that they take different type of inputs.
 For example apply works on data frames or matrices and applies the function
 on each row or column of the data structure.
 lapply works on lists or vectors and applies a function which takes the
 list element as an argument.
 Next we will demonstrate how to use apply() on a matrix.
 The example applies the sum function on the rows of a matrix, it basically
 sums up the values on each row of the matrix, which is conceptualized in
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "mar:apply-on-a-matrix"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float marginfigure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename nonR_figures/apply.pdf
	scale 50
	clip

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
apply on rows
\begin_inset CommandInset label
LatexCommand label
name "mar:apply-on-a-matrix"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

mat=cbind(c(3,0,3,3),c(3,0,0,0),c(3,0,0,3),c(1,1,0,0),c(1,1,1,0),c(1,1,1,0))
\end_layout

\begin_layout Plain Layout

result<-apply(mat,1,sum)
\end_layout

\begin_layout Plain Layout

result
\end_layout

\begin_layout Plain Layout

# OR you can define the function as an argument to apply() 
\end_layout

\begin_layout Plain Layout

result<-apply(mat,1,function(x) sum(x))
\end_layout

\begin_layout Plain Layout

result
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Notice that we used a second argument which equals to 1, that indicates
 that rows of the matrix/ data frame will be the input for the function.
 If we change the second argument to 2, this will indicate that columns
 should be the input for the function that will be applied.
 See Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "mar:apply-on-columns"

\end_inset

 for the visualization of apply() on columns.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

result<-apply(mat,2,sum)
\end_layout

\begin_layout Plain Layout

result
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float marginfigure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename nonR_figures/apply2.pdf
	scale 50
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
apply on columns
\begin_inset CommandInset label
LatexCommand label
name "mar:apply-on-columns"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
next we will use lapply, which applies a function on a list or a vector.
 The function that will be applied is a simple function that takes the square
 of a given number.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

input=c(1,2,3)
\end_layout

\begin_layout Plain Layout

lapply(input,function(x) x^2)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
mapply is another member of apply family, it can apply a function on an
 unlimited set of vectors/lists, it is like a version of lapply that can
 handle multiple vectors as arguments.
 In this case, the argument to the mapply() is the function to be applied
 and the sets of parameters to be supplied as arguments of the function.
 This conceptualized Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "mar:mapply-takes-in"

\end_inset

, the function to be applied is a function that takes to arguments and sums
 them up.
 The arguments to be summed up are in the format of vectors, Xs and Ys.
 mapply() applies the summation function to each pair in Xs and Ys vector.
 Notice that the order of the input function and extra arguments are different
 for mapply.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

Xs=0:5
\end_layout

\begin_layout Plain Layout

Ys=c(2,2,2,3,3,3)
\end_layout

\begin_layout Plain Layout

result<-mapply(function(x,y) sum(x,y),Xs,Ys)
\end_layout

\begin_layout Plain Layout

result
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float marginfigure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename nonR_figures/mapply.pdf
	scale 50
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
mapply takes in multiple/vectors and lists
\begin_inset CommandInset label
LatexCommand label
name "mar:mapply-takes-in"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
apply family functions on multiple cores
\end_layout

\begin_layout Standard
If you have large data sets apply-family functions can be slow (although
 probably still better than for loops).
 If that is the case, you can easily use the parallel versions of those
 functions from parallel package.
 These functions essentially divide your tasks to smaller chunks run them
 on separate CPUs and merge the results from those parallel operations.
 This concept is visualized at Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "mar:mcmapply-on-3"

\end_inset

, mcapply runs the summation function on three different processors.
 Each processor executes the summation function on a part of the data set,
 and the results are merged and returned as a single vector that has the
 same order as the input parameters Xs and Ys.
\end_layout

\begin_layout Standard
\begin_inset Float marginfigure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename nonR_figures/mcmapply.pdf
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
mcmapply on 3 cores
\begin_inset CommandInset label
LatexCommand label
name "mar:mcmapply-on-3"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Vectorized functions in R
\end_layout

\begin_layout Standard
The above examples have been put forward to illustrate functions and loops
 in R because functions using sum() are not complicated and easy to understand.
 You will probably need to use loops and looping structures with more complicate
d functions.
 In reality, most of the operations we used do not need the use of loops
 or looping structures because there are already vectorized functions that
 can achieve the same outcomes, meaning if the input arguments are R vectors
 the output will be a vector as well, so no need for loops or vectorization.
\end_layout

\begin_layout Standard
For example, instead of using mapply() and sum() functions we can just use
 + operator and sum up Xs and Ys.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

result=Xs+Ys
\end_layout

\begin_layout Plain Layout

result
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In order to get the column or row sums, we can use the vectorized functions
 colSums() and rowSums()
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

colSums(mat)
\end_layout

\begin_layout Plain Layout

rowSums(mat)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
However, remember that not every function is vectorized in R, use the ones
 that are.
 But sooner or later, apply family functions will come in handy.
\end_layout

\begin_layout Section
Session Info
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

sessionInfo()
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Section
Acknowledgements
\end_layout

\begin_layout Standard
Chapter is initiated by Altuna Akalin.
\end_layout

\end_body
\end_document
